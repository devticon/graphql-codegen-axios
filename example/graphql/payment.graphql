fragment PaymentMinimal on Payment {
  id
  orderId
}
fragment Payment on Payment {
  id
  createdAt
  currency
  status
  orderId
  orderCurrencyAmount
  paymentMethodId
  amount
  ip
  paymentTokenId
  voucherId
  cardId
  externalId
  providerId
}

mutation updatePaymentById ($id: uuid! $input: PaymentSetInput!) {
  updatePaymentByPk(pk_columns: {id: $id} _set: $input) {
    id
  }
}

query getPaymentById($id: uuid!) {
  paymentByPk(id: $id) @nonNullable {
    ...Payment
  }
}

query getPaymentByIdWithAggregates($id: uuid!) {
  paymentByPk(id: $id) @nonNullable {
    ...Payment
    refundedAmount
  }
}

query getPaymentByRefundId($refundId: uuid!) {
  payment(where: {refunds: {id: {_eq: $refundId}}}) @firstOrFail {
    ...Payment
  }
}

query getPaidPaymentByOrderId($orderId: uuid!) {
  payment(where: {orderId: {_eq: $orderId}}) {
    ...Payment
  }
}

query getPendingPaymentsByOrderId($orderId: uuid!) {
  payment(where: {orderId: {_eq: $orderId}}) {
    ...PaymentMinimal
  }
}

query getPaymentForRefund($paymentId: uuid! $projectId: uuid!) {
  payment(where: {id: {_eq: $paymentId} order: {projectId: {_eq: $projectId}}} limit: 1) @firstOrFail {
    ...Payment
    canBeRefunded
  }
}

mutation createPayment($input: PaymentInsertInput!) {
  insertPaymentOne(object: $input)@nonNullable {
    ...Payment
  }
}
query getPaymentReturnUrlById($id: uuid!) {
  paymentByPk(id: $id) @nonNullable {
    returnUrl
  }
}

mutation rejectUnfinishedPayments($before: timestamp) {
  updatePayment(where: {
    createdAt: {_lt: $before}
    status: {_in: [PENDING, CREATED]}
  }) {
    affected_rows
  }
}

query getFirstPaidPaymentByOrderId($orderId: uuid!) {
  payment(where: {status: {_eq: PAID} orderId: {_eq: $orderId}}) @firstOrFail {
    ...Payment
  }
}